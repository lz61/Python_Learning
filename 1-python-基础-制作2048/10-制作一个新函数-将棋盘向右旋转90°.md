1.在向左移动90°之后,我们可以类似地构建向上、向右、向下移动的办法。但是这个办法太过繁琐，我们可以自己思考一下：有没有更好的办法？

2.有的,旋转棋盘就是一解.

3.旋转棋盘的具象化:

```
[0 0 0 1]
[0 0 0 0]
[0 0 0 0]
[0 0 0 0]
```

右转90°:

```
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 1
```

左移:

```
0
0
0
1
```

再右转3次:

```
0 0 0 0
...
...
0 0 0 1
```

因此右转一次代表的是S.

5.问题:

如何旋转棋盘?

利用初中学过的一线三直角的知识,

已知:

将矩阵中的元素看作(i,j)的坐标,然后绕着中心点旋转90°.

中心点坐标: (1.5,1.5)

上图:

![image-20250723165338968](C:\Users\AmpMing\AppData\Roaming\Typora\typora-user-images\image-20250723165338968.png)

注: 当然,我们可以推理任何的一个n*n的矩阵在顺时针旋转90°之后的样子,但是这对于我们目前的游戏来说太复杂,没必要.



6.代码测试:

(理想的代码)

```
mat = [
    [0,0,0,1],
    [0,0,0,0],
    [0,0,0,0],
    [0,0,0,0]
]

def rightRotateMatrix(matrix):
    n = 4
    newMat = [
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0]
    ]
    for i in range(n):
        for j in range(n):
            newMat[i][j] = matrix[3-j][i]
    matrix = newMat
    return matrix

rightRotateMatrix(mat)
print(mat)
assert mat == [
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 1]
], "The matrix was not rotated correctly."

```



但是: 并没有成功!

这是为什么?



7.思考?如何找出自己写的代码的问题?



8.妥协方案: 用函数return的对象来改变mat的值.

之后,让我们深入研究函数究竟能否改变"传入变量"的值.