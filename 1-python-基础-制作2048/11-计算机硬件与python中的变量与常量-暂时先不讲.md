1.问题: 什么时候能改变变量的值?什么时候又不能?

实例代码:

代码1: 通过函数访问来修改一些变量的值:

```
mat = [1,2,3,4]
def changeMat(matrix):
    matrix[0] = 2
    return matrix

changeMat(mat)
print(mat)
```

okay!



代码2: 修改所有mat的值:

```
mat = [1,2,3,4]
def changeMat(matrix):
    matrix = [1,2,3,5]
    return matrix

changeMat(mat)
print(mat)
```

不行? 输入的mat没有改变?



2.在解决这个问题之前,让我们看看计算机的基本组成部分,并让我解释一下计算机基本组成部分的各自的实例.

基本组成部分: 软件,操作系统,硬件.

软件: 各种各样,比如浏览器,设置,...有图标的内容都可以算作软件.

操作系统: Windows,Mac,Linux.三大主流.

硬件: 目前你需要知道的只有两个: CPU,内存条.



3.让我们认真看一下CPU和内存条.

参考视频: https://www.bilibili.com/video/BV1BG4y137mG/?spm_id_from=333.788.recommend_more_video.-1&vd_source=4300f1d531a3be89d0c675d10937bbb3

从1min15s开始看起,简单看一下两者的外观.以及,所有电脑里都有这两个东西.(因为它们是电脑组成所必须的硬件!)



4.让我们来详细介绍一下CPU和内存条在电脑运转中发挥的功效.

CPU负责: 做各种各样的计算.当然,CPU中也可以存储一定量的数据,CPU中的数据放在一个叫"寄存器"的东西里面.

内存条: 负责储存数据,程序运行时申请的数据默认会放在内存条中.(不默认放在寄存器中,因为寄存器容量太小).



注1: 有一条原则很重要: 在计算机中,除了CPU以外的部件都只是用来配合CPU工作的!也就是说,除了CPU以外的所有

部件不会"主动"做某些事情.

比喻: CPU就像电脑的"大脑".人类所做的所有主动行为(比如喝水,吃饭,跑步)都是由大脑控制的.如果没有大脑,人的

其他部位并不会"主动"做一些事.

当CPU需要计算数据时,它就从内存条中取出数据进行计算,再把值传回给内存条.



注2: 为什么要分离CPU和内存条? 在制作它们的时候,直接让机器把它们做在一起不好么?

不好! CPU负责控制一切,发号施令,内存条负责响应CPU的命令.

从根本上来说,这件事节约了大量电脑制作的成本!为什么?



注3: 当我们以后提到计算机的"内存条"时,代表我们提到的是一个"具象"的实体,也就是一根根的内存条.

而计算机的"内存"指的是一个抽象的概念.



例如,如果一个计算机硬件上有4根内存条,每根内存条可以存储4GB的数据,我们就说这个计算机的内存是16G.

所以这句话也可以改写为:

当CPU需要计算数据时,它就从内存中取出数据进行计算,再把值传回给内存.(内存的实质就是内存条,只是我们对它

做了逻辑上的抽象.)



5.这一切和我们的程序有什么关系? 事实上,我们现在知道了一件事: 变量的存储和计算是分离的.

存储由内存条所实现,而计算由CPU所实现.

神奇的地方来了:

```
x=1
y=2
print(x+y)
```

在这段代码的执行过程中,CPU和内存条各自发挥了什么作用?



思考并模拟:

```
x=1
# 内存条中某个地方存储了一个值,这个值为1
y=2
# 内存条中某个地方存储了一个值,这个值为2
print(x+y)
# 因为内存条只负责存储,做不了计算,所以这句话需要CPU和内存条一起发力
# 第一步: 内存条把x,y对应的值1,2发送给CPU
# 第二步: CPU计算答案得到3
# 第三步: CPU返回3给内存条,内存条在某个地方存储了一个值为3
# 第四步: 输出3
```





6.思考: 内存是如何储存值的?

我们之前说,内存条并不能"主动"做一件事,所以"内存条存储值"本质上应该是"CPU指挥内存条存储值".

也就是说,CPU对内存条说: 请给我存储一个变量,它的值是1,它的名字是x!

内存条说: 嘿!哥们!我做不到啊!我只是存储数据的,要存名字你自己想办法!

CPU说: 好吧.那么这样,假设你内存里面只能最多存储10个变量,那么是不是每个变量有一个对应的编号?不妨从0开

始编号,编到9吧.(为什么是从0开始编号不是从1开始编号? 这个我们之后有时间会解释,不过要解释的话又要花掉很

多时间,这里让我们先忽略这个问题.)

内存条说: 没问题!生产我的厂商早就想好这么做了!

CPU说: 好的,那你把值1存到编号9的地方,这个编号9就是变量x的地址,我自己把编号9记住,你负责把值1存进去就行!

内存条: Yes Sir!



7.类似地,CPU可以让内存在编号为8的地方存储值2,它自己把y变量的编号8记住就好.



这里所谓的编号就是变量在内存空间中的**地址**,简称为**变量地址**.





8.当CPU需要取出x,y的值时,

它只需要问内存: 你在**地址**9,8的地方存储了哪些值?

内存说: 1,2啊.

CPU说: 好的,我加一下,得到3咯!



9.这就是所谓的CPU,内存,以及它们和程序的交互过程.

说了这么多,其实就是一句话: 任何数据,在计算机里都有它的存放地址! 我在拿这个数据的时候,其实是问对应的地址中的值是多少.





以下为python的数据管理机制.



10.python的数据管理机制:

python中,只有常量有地址,变量只是一个"标签".

python中的变量只是一个标签.它指向自己控制的"常量"的地址.

如何得到变量所代表的常量的地址:用id函数

```
print(id(x)) #输出变量x的地址
# 甚至可以这样写:
print(id(1))
```

让我来解释这句话并给你看一些神奇的东西.



11.python中数值类型常量的创建:

假如有这样的一段代码:

```
x=1
x=2
y=1
y=2
```



开始执行前:

```
内存池位置        数据的值
```

什么也没有.



执行完第一行后:

```
内存池位置                              数据的值
0(不一定是0,可能是任意一个位置)               1(此时x指向1)
```



执行完第二行后:

```
内存池位置                             数据的值
0(不一定是0,可能是任意一个位置)               1
1                                         2(此时x指向2)
```



执行完第三行后:

```
内存池位置                             数据的值
0(不一定是0,可能是任意一个位置)               1(y指向1)
1                                         2(此时x指向2)
```

执行完第四行后:

```
内存池位置                             数据的值
0(不一定是0,可能是任意一个位置)               1
1                                         2(此时x指向2,y也指向2)
```





测试:

```
x=1
print(id(x))
x=2
print(id(x))
y=1
print(id(y))
y=2
print(id(y))
```



12.python中列表类型常量的创建:

可以想象,当我们创建[1,2]时,我们:

1.先创建两个数字1,2,并分配给它们对应的地址

2.再创建一个列表,并让它里面存储1,2的地址.

```
x=[1,2]
```

常量池:

```
内存池位置   数据的值
11111         数值对象,值为1
22222         数值对象,值为2
3          列表对象,值为[11111,22222]
也就是说,列表对象不存储数值对象,而是只存储数值对象的地址!
```

而x=[1,2],就是让x和列表对象挂钩而已!



13.让我们分析一下这段代码发生了什么:

```
x=[1,2]
x=[1,2,3]
x=1
```

分析:

发生了什么?



14.不好意思,以上有一些话是骗人的:

事实上,python为了方便起见,在程序运行的开始阶段,就会在内存池中创建-5~256这些数字,所以这些数字其实不需

要用户需求就会被python创建出来.

但是这个理念是很有趣的.

注: python中,不是所有常量都只会被创建一次.有一些特定的规则.

